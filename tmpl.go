package main

const tmpl = `// This code was autogenerated from protoc-gen-dragonboat, do not edit.
package {{ package . }}

import (
	"fmt"
	"context"
	"runtime/debug"

	"google.golang.org/protobuf/proto"
	sm "github.com/lni/dragonboat/v3/statemachine"

	"github.com/LilithGames/protoc-gen-dragonboat/runtime"
)
{{- range .Services }}
{{- $svc := .Name }}

type I{{ $svc }}DragonboatServer interface {
{{- range .Methods }}
	{{ name . }}(req *{{ name .Input }}) (*{{ name .Output }}, error)
{{- end }}
}

type I{{ $svc }}DragonboatClient interface {
{{- range .Methods }}
	{{ name . }}(ctx context.Context, req *{{ name .Input }}, opts ...runtime.DragonboatClientOption) (*{{ name .Output }}, error)
{{- end }}
}

func Dragonboat{{ $svc }}Lookup(s I{{ $svc }}DragonboatServer, query interface{}) (result interface{}, err error) {
	defer func() {
		if perr := recover(); perr != nil {
			err = fmt.Errorf("panic: %v\nstacktrace from panic: %s", perr, string(debug.Stack()))
		}
	}()
	switch q := query.(type) {
{{- range .Methods }}
{{- $moptions := options . }}
{{- $mtype := default $moptions.Type "query" }}
{{- if (eq $mtype "query")}}
	case *{{ name .Input }}:
		resp, err := s.{{ name . }}(q)
		if err != nil {
			return resp, fmt.Errorf("I{{ $svc }}Server.{{ name . }}(%v) err: %w", q, err)
		}
		return resp, nil
{{- end }}
{{- end }}
	case nil:
		// healthcheck
		return nil, nil
	default:
		return nil, fmt.Errorf("%w(type: %T)", runtime.ErrUnknownRequest, q)
	}
}

func Dragonboat{{ $svc }}UpdateDispatch(s I{{ $svc }}DragonboatServer, msg proto.Message) (result proto.Message, err error) {
	defer func() {
		if perr := recover(); perr != nil {
			err = fmt.Errorf("panic: %v\nstacktrace from panic: %s", perr, string(debug.Stack()))
		}
	}()
	switch m := msg.(type) {
{{- range .Methods }}
{{- $moptions := options . }}
{{- $mtype := default $moptions.Type "query" }}
{{- if (eq $mtype "mutation")}}
	case *{{ name .Input }}:
		resp, err := s.{{ name . }}(m)
		return resp, err
{{- end }}
{{- end }}
	default:
		return nil, fmt.Errorf("%w(type: %T)", runtime.ErrUnknownRequest, m)
	}
}

func Dragonboat{{ $svc }}Update(s I{{ $svc }}DragonboatServer, data []byte) (sm.Result, error) {
	msg, err := runtime.ParseDragonboatRequest(data)
	if err != nil {
		return runtime.MakeDragonboatResult(nil, err), nil
	}
	resp, err := Dragonboat{{ $svc }}UpdateDispatch(s, msg)
	return runtime.MakeDragonboatResult(resp, err), nil
}

func Dragonboat{{ $svc }}ConcurrencyUpdate(s I{{ $svc }}DragonboatServer, entries []sm.Entry) ([]sm.Entry, error) {
	for i := range entries {
		entry := &entries[i]
		msg, err := runtime.ParseDragonboatRequest(entry.Cmd)
		if err != nil {
			entry.Result = runtime.MakeDragonboatResult(nil, err)
		} else {
			resp, err := Dragonboat{{ $svc }}UpdateDispatch(s, msg)
			entry.Result = runtime.MakeDragonboatResult(resp, err)
		}
	}
	return entries, nil
}

type {{ $svc }}DragonboatClient struct {
	client runtime.IDragonboatClient
}

func New{{ $svc }}DragonboatClient(client runtime.IDragonboatClient) I{{ $svc }}DragonboatClient {
	return &{{ $svc }}DragonboatClient{client: client}
}

{{- range .Methods }}
{{- $moptions := options . }}
{{- $mtype := default $moptions.Type "query" }}
func (it *{{ $svc }}DragonboatClient) {{ name . }}(ctx context.Context, req *{{ name .Input }}, opts ...runtime.DragonboatClientOption) (*{{ name .Output }}, error) {
{{- if (eq $mtype "query")}}
	resp, err := it.client.Query(ctx, req, opts...)
{{- else }}
	resp, err := it.client.Mutate(ctx, req, opts...)
{{- end }}
	if r, ok := resp.(*{{ name .Output }}); ok {
		return r, err
	} else if err != nil {
		return nil, err
	} else {
		return nil, fmt.Errorf("cannot parse %T response type to *{{ name .Output }}", resp)
	}
}
{{- end }}

{{- end }}
`
